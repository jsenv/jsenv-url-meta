{"version":3,"file":"main.js","sources":["/src/assertUrlLike.js","/src/applySpecifierPatternMatching/applySpecifierPatternMatching.js","/src/isPlainObject.js","/src/metaMapToSpecifierMetaMap/metaMapToSpecifierMetaMap.js","/src/assertSpecifierMetaMap.js","/src/normalizeSpecifierMetaMap/normalizeSpecifierMetaMap.js","/src/urlCanContainsMetaMatching/urlCanContainsMetaMatching.js","/src/urlToMeta/urlToMeta.js"],"sourcesContent":["export const assertUrlLike = (value, name = \"url\") => {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`${name} must be a url string, got ${value}`)\n  }\n  if (isWindowsPathnameSpecifier(value)) {\n    throw new TypeError(`${name} must be a url but looks like a windows pathname, got ${value}`)\n  }\n  if (!hasScheme(value)) {\n    throw new TypeError(`${name} must be a url and no scheme found, got ${value}`)\n  }\n}\n\nconst isWindowsPathnameSpecifier = (specifier) => {\n  const firstChar = specifier[0]\n  if (!/[a-zA-Z]/.test(firstChar)) return false\n  const secondChar = specifier[1]\n  if (secondChar !== \":\") return false\n  const thirdChar = specifier[2]\n  return thirdChar === \"/\"\n}\n\nconst hasScheme = (specifier) => /^[a-zA-Z]+:/.test(specifier)\n","// https://git-scm.com/docs/gitignore\n// https://github.com/kaelzhang/node-ignore\n\nimport { assertUrlLike } from \"../assertUrlLike.js\"\n\nexport const applySpecifierPatternMatching = ({ specifier, url } = {}) => {\n  assertUrlLike(specifier, \"specifier\")\n  assertUrlLike(url, \"url\")\n  return applyPatternMatching(specifier, url)\n}\n\nconst applyPatternMatching = (pattern, string) => {\n  let patternIndex = 0\n  let index = 0\n  let remainingPattern = pattern\n  let remainingString = string\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    //  '' === '' -> pass\n    if (remainingPattern === \"\" && remainingString === \"\") {\n      return pass({\n        patternIndex,\n        index,\n      })\n    }\n\n    // '' === value -> fail\n    if (remainingPattern === \"\" && remainingString !== \"\") {\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // pattern === '' -> pass only if pattern is only **\n    if (remainingPattern !== \"\" && remainingString === \"\") {\n      // pass because pattern is optionnal\n      if (remainingPattern === \"**\") {\n        return pass({\n          patternIndex,\n          index,\n        })\n      }\n\n      // fail because **/ would expect something like /a\n      // and **a would expect something like foo/bar/a\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    if (remainingPattern.slice(0, \"**\".length) === \"**\") {\n      patternIndex += `**`.length\n      remainingPattern = remainingPattern.slice(`**`.length)\n      if (remainingPattern[0] === \"/\") {\n        patternIndex += \"/\".length\n        remainingPattern = remainingPattern.slice(\"/\".length)\n      }\n\n      // pattern ending with ** always match remaining string\n      if (remainingPattern === \"\") {\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      const skipResult = skipUntilMatch({ pattern: remainingPattern, string: remainingString })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] === \"*\") {\n      patternIndex += \"*\".length\n      remainingPattern = remainingPattern.slice(\"*\".length)\n\n      // la c'est plus délicat, il faut que remainingString\n      // ne soit composé que de truc !== '/'\n      if (remainingPattern === \"\") {\n        const slashIndex = remainingString.indexOf(\"/\")\n        if (slashIndex > -1) {\n          return fail({\n            patternIndex,\n            index: index + slashIndex,\n          })\n        }\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      // the next char must not the one expected by remainingPattern[0]\n      // because * is greedy and expect to skip one char\n      if (remainingPattern[0] === remainingString[0]) {\n        return fail({\n          patternIndex: patternIndex - \"*\".length,\n          index,\n        })\n      }\n\n      const skipResult = skipUntilMatch({\n        pattern: remainingPattern,\n        string: remainingString,\n        skippablePredicate: (remainingString) => remainingString[0] !== \"/\",\n      })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] !== remainingString[0]) {\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // trailing slash on pattern, -> match remaining\n    if (remainingPattern === \"/\" && remainingString.length > 1) {\n      return pass({\n        patternIndex: patternIndex + 1,\n        index: string.length,\n      })\n    }\n\n    patternIndex += 1\n    index += 1\n    remainingPattern = remainingPattern.slice(1)\n    remainingString = remainingString.slice(1)\n    continue\n  }\n}\n\nconst skipUntilMatch = ({ pattern, string, skippablePredicate = () => true }) => {\n  let index = 0\n  let remainingString = string\n  let bestMatch = null\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matchAttempt = applyPatternMatching(pattern, remainingString)\n\n    if (matchAttempt.matched) {\n      bestMatch = matchAttempt\n      break\n    }\n\n    const skippable = skippablePredicate(remainingString)\n\n    bestMatch = fail({\n      patternIndex: bestMatch\n        ? Math.max(bestMatch.patternIndex, matchAttempt.patternIndex)\n        : matchAttempt.patternIndex,\n      index: index + matchAttempt.index,\n    })\n\n    if (!skippable) {\n      break\n    }\n\n    // search against the next unattempted string\n    index += matchAttempt.index + 1\n    remainingString = remainingString.slice(matchAttempt.index + 1)\n    if (remainingString === \"\") {\n      bestMatch = {\n        ...bestMatch,\n        index: string.length,\n      }\n      break\n    }\n\n    continue\n  }\n\n  return bestMatch\n}\n\nconst pass = ({ patternIndex, index }) => {\n  return {\n    matched: true,\n    index,\n    patternIndex,\n  }\n}\n\nconst fail = ({ patternIndex, index }) => {\n  return {\n    matched: false,\n    index,\n    patternIndex,\n  }\n}\n","export const isPlainObject = (value) => {\n  if (value === null) {\n    return false\n  }\n  if (typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      return false\n    }\n    return true\n  }\n  return false\n}\n","import { isPlainObject } from \"../isPlainObject.js\"\n\nexport const metaMapToSpecifierMetaMap = (metaMap) => {\n  if (!isPlainObject(metaMap)) {\n    throw new TypeError(`metaMap must be a plain object, got ${metaMap}`)\n  }\n\n  const specifierMetaMap = {}\n\n  Object.keys(metaMap).forEach((metaKey) => {\n    const specifierValueMap = metaMap[metaKey]\n    if (!isPlainObject(specifierValueMap)) {\n      throw new TypeError(\n        `metaMap value must be plain object, got ${specifierValueMap} for ${metaKey}`,\n      )\n    }\n    Object.keys(specifierValueMap).forEach((specifier) => {\n      const metaValue = specifierValueMap[specifier]\n      const meta = { [metaKey]: metaValue }\n      specifierMetaMap[specifier] =\n        specifier in specifierMetaMap ? { ...specifierMetaMap[specifier], ...meta } : meta\n    })\n  })\n\n  return specifierMetaMap\n}\n","import { isPlainObject } from \"./isPlainObject.js\"\n\nexport const assertSpecifierMetaMap = (value) => {\n  if (!isPlainObject(value)) {\n    throw new TypeError(`specifierMetaMap must be a plain object, got ${value}`)\n  }\n  // we could ensure it's key/value pair of url like key/object or null values\n}\n","import { assertSpecifierMetaMap } from \"../assertSpecifierMetaMap.js\"\n\nexport const normalizeSpecifierMetaMap = (specifierMetaMap, url) => {\n  assertSpecifierMetaMap(specifierMetaMap)\n\n  const specifierMetaMapNormalized = {}\n  Object.keys(specifierMetaMap).forEach((specifier) => {\n    const specifierResolved = String(new URL(specifier, url))\n    specifierMetaMapNormalized[specifierResolved] = specifierMetaMap[specifier]\n  })\n  return specifierMetaMapNormalized\n}\n","import { assertUrlLike } from \"../assertUrlLike.js\"\nimport { assertSpecifierMetaMap } from \"../assertSpecifierMetaMap.js\"\nimport { applySpecifierPatternMatching } from \"../applySpecifierPatternMatching/applySpecifierPatternMatching.js\"\n\nexport const urlCanContainsMetaMatching = ({ url, specifierMetaMap, predicate }) => {\n  assertUrlLike(url, \"url\")\n  assertSpecifierMetaMap(specifierMetaMap)\n  if (typeof predicate !== \"function\") {\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n  }\n\n  // we add a trailing slash because we are intested into what will be inside\n  // this url, not the url itself\n  // it allows to match pattern for what is inside\n  const urlWithTrailingSlash = `${url}/`\n\n  // for full match we must create an object to allow pattern to override previous ones\n  let fullMatchMeta = {}\n  let someFullMatch = false\n  // for partial match, any meta satisfying predicate will be valid because\n  // we don't know for sure if pattern will still match for a file inside pathname\n  const partialMatchMetaArray = []\n\n  Object.keys(specifierMetaMap).forEach((specifier) => {\n    const meta = specifierMetaMap[specifier]\n    const { matched, index } = applySpecifierPatternMatching({\n      specifier,\n      url: urlWithTrailingSlash,\n    })\n    if (matched) {\n      someFullMatch = true\n      fullMatchMeta = {\n        ...fullMatchMeta,\n        ...meta,\n      }\n    } else if (someFullMatch === false && index >= url.length) {\n      partialMatchMetaArray.push(meta)\n    }\n  })\n\n  if (someFullMatch) {\n    return Boolean(predicate(fullMatchMeta))\n  }\n\n  return partialMatchMetaArray.some((partialMatchMeta) => predicate(partialMatchMeta))\n}\n","import { assertSpecifierMetaMap } from \"../assertSpecifierMetaMap.js\"\nimport { assertUrlLike } from \"../assertUrlLike.js\"\nimport { applySpecifierPatternMatching } from \"../applySpecifierPatternMatching/applySpecifierPatternMatching.js\"\n\nexport const urlToMeta = ({ url, specifierMetaMap } = {}) => {\n  assertUrlLike(url)\n  assertSpecifierMetaMap(specifierMetaMap)\n\n  return Object.keys(specifierMetaMap).reduce((previousMeta, specifier) => {\n    const { matched } = applySpecifierPatternMatching({\n      specifier,\n      url,\n    })\n    return matched ? { ...previousMeta, ...specifierMetaMap[specifier] } : previousMeta\n  }, {})\n}\n"],"names":["assertUrlLike","value","name","TypeError","isWindowsPathnameSpecifier","hasScheme","specifier","firstChar","test","secondChar","thirdChar","applySpecifierPatternMatching","url","applyPatternMatching","pattern","string","patternIndex","index","remainingPattern","remainingString","pass","fail","slice","length","skipResult","skipUntilMatch","matched","slashIndex","indexOf","skippablePredicate","bestMatch","matchAttempt","skippable","Math","max","isPlainObject","Array","isArray","metaMapToSpecifierMetaMap","metaMap","specifierMetaMap","Object","keys","forEach","metaKey","specifierValueMap","metaValue","meta","assertSpecifierMetaMap","normalizeSpecifierMetaMap","specifierMetaMapNormalized","specifierResolved","String","URL","urlCanContainsMetaMatching","predicate","urlWithTrailingSlash","fullMatchMeta","someFullMatch","partialMatchMetaArray","push","Boolean","some","partialMatchMeta","urlToMeta","reduce","previousMeta"],"mappings":"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"}