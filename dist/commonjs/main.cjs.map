{
  "version": 3,
  "file": "main.cjs",
  "sources": [
    "../../src/internal/assertUrlLike.js",
    "../../src/applySpecifierPatternMatching.js",
    "../../src/internal/isPlainObject.js",
    "../../src/metaMapToSpecifierMetaMap.js",
    "../../src/internal/assertSpecifierMetaMap.js",
    "../../src/normalizeSpecifierMetaMap.js",
    "../../src/urlCanContainsMetaMatching.js",
    "../../src/urlToMeta.js"
  ],
  "sourcesContent": [
    "export const assertUrlLike = (value, name = \"url\") => {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`${name} must be a url string, got ${value}`)\n  }\n  if (isWindowsPathnameSpecifier(value)) {\n    throw new TypeError(`${name} must be a url but looks like a windows pathname, got ${value}`)\n  }\n  if (!hasScheme(value)) {\n    throw new TypeError(`${name} must be a url and no scheme found, got ${value}`)\n  }\n}\n\nconst isWindowsPathnameSpecifier = (specifier) => {\n  const firstChar = specifier[0]\n  if (!/[a-zA-Z]/.test(firstChar)) return false\n  const secondChar = specifier[1]\n  if (secondChar !== \":\") return false\n  const thirdChar = specifier[2]\n  return thirdChar === \"/\" || thirdChar === \"\\\\\"\n}\n\nconst hasScheme = (specifier) => /^[a-zA-Z]+:/.test(specifier)\n",
    "// https://git-scm.com/docs/gitignore\n// https://github.com/kaelzhang/node-ignore\n\nimport { assertUrlLike } from \"./internal/assertUrlLike.js\"\n\nexport const applySpecifierPatternMatching = ({ specifier, url, ...rest } = {}) => {\n  assertUrlLike(specifier, \"specifier\")\n  assertUrlLike(url, \"url\")\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\nspecifier, url`)\n  }\n  return applyPatternMatching(specifier, url)\n}\n\nconst applyPatternMatching = (pattern, string) => {\n  let patternIndex = 0\n  let index = 0\n  let remainingPattern = pattern\n  let remainingString = string\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // pattern consumed and string consumed\n    if (remainingPattern === \"\" && remainingString === \"\") {\n      // pass because string fully matched pattern\n      return pass({\n        patternIndex,\n        index,\n      })\n    }\n\n    // pattern consumed, string not consumed\n    if (remainingPattern === \"\" && remainingString !== \"\") {\n      // fails because string longer than expected\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // from this point pattern is not consumed\n\n    // string consumed, pattern not consumed\n    if (remainingString === \"\") {\n      // pass because trailing \"**\" is optional\n      if (remainingPattern === \"**\") {\n        return pass({\n          patternIndex: patternIndex + 2,\n          index,\n        })\n      }\n      // fail because string shorted than expected\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // from this point pattern and string are not consumed\n\n    // fast path trailing slash\n    if (remainingPattern === \"/\") {\n      // pass because trailing slash matches remaining\n      if (remainingString[0] === \"/\") {\n        return pass({\n          patternIndex: patternIndex + 1,\n          index: string.length,\n        })\n      }\n\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // fast path trailing '**'\n    if (remainingPattern === \"**\") {\n      // pass because trailing ** matches remaining\n      return pass({\n        patternIndex: patternIndex + 2,\n        index: string.length,\n      })\n    }\n\n    // pattern leading **\n    if (remainingPattern.slice(0, 2) === \"**\") {\n      // consumes \"**\"\n      remainingPattern = remainingPattern.slice(2)\n      patternIndex += 2\n      if (remainingPattern[0] === \"/\") {\n        // consumes \"/\"\n        remainingPattern = remainingPattern.slice(1)\n        patternIndex += 1\n      }\n\n      // pattern ending with ** always match remaining string\n      if (remainingPattern === \"\") {\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      const skipResult = skipUntilMatch({ pattern: remainingPattern, string: remainingString })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] === \"*\") {\n      // consumes \"*\"\n      remainingPattern = remainingPattern.slice(1)\n      patternIndex += 1\n\n      // la c'est plus délicat, il faut que remainingString\n      // ne soit composé que de truc !== '/'\n      if (remainingPattern === \"\") {\n        const slashIndex = remainingString.indexOf(\"/\")\n        if (slashIndex > -1) {\n          return fail({\n            patternIndex,\n            index: index + slashIndex,\n          })\n        }\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      // the next char must not the one expected by remainingPattern[0]\n      // because * is greedy and expect to skip one char\n      if (remainingPattern[0] === remainingString[0]) {\n        return fail({\n          patternIndex: patternIndex - \"*\".length,\n          index,\n        })\n      }\n\n      const skipResult = skipUntilMatch({\n        pattern: remainingPattern,\n        string: remainingString,\n        skippablePredicate: (remainingString) => remainingString[0] !== \"/\",\n      })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] !== remainingString[0]) {\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // consumes next char\n    remainingPattern = remainingPattern.slice(1)\n    remainingString = remainingString.slice(1)\n    patternIndex += 1\n    index += 1\n    continue\n  }\n}\n\nconst skipUntilMatch = ({ pattern, string, skippablePredicate = () => true }) => {\n  let index = 0\n  let remainingString = string\n  let bestMatch = null\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matchAttempt = applyPatternMatching(pattern, remainingString)\n\n    if (matchAttempt.matched) {\n      bestMatch = matchAttempt\n      break\n    }\n\n    const skippable = skippablePredicate(remainingString)\n\n    bestMatch = fail({\n      patternIndex: bestMatch\n        ? Math.max(bestMatch.patternIndex, matchAttempt.patternIndex)\n        : matchAttempt.patternIndex,\n      index: index + matchAttempt.index,\n    })\n\n    if (!skippable) {\n      break\n    }\n\n    // search against the next unattempted string\n    remainingString = remainingString.slice(matchAttempt.index + 1)\n    index += matchAttempt.index + 1\n    if (remainingString === \"\") {\n      bestMatch = {\n        ...bestMatch,\n        index: string.length,\n      }\n      break\n    }\n\n    continue\n  }\n\n  return bestMatch\n}\n\nconst pass = ({ patternIndex, index }) => {\n  return {\n    matched: true,\n    index,\n    patternIndex,\n  }\n}\n\nconst fail = ({ patternIndex, index }) => {\n  return {\n    matched: false,\n    index,\n    patternIndex,\n  }\n}\n",
    "export const isPlainObject = (value) => {\n  if (value === null) {\n    return false\n  }\n  if (typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      return false\n    }\n    return true\n  }\n  return false\n}\n",
    "import { isPlainObject } from \"./internal/isPlainObject.js\"\n\nexport const metaMapToSpecifierMetaMap = (metaMap, ...rest) => {\n  if (!isPlainObject(metaMap)) {\n    throw new TypeError(`metaMap must be a plain object, got ${metaMap}`)\n  }\n  if (rest.length) {\n    throw new Error(`received more arguments than expected.\n--- number of arguments received ---\n${1 + rest.length}\n--- number of arguments expected ---\n1`)\n  }\n\n  const specifierMetaMap = {}\n\n  Object.keys(metaMap).forEach((metaKey) => {\n    const specifierValueMap = metaMap[metaKey]\n    if (!isPlainObject(specifierValueMap)) {\n      throw new TypeError(\n        `metaMap value must be plain object, got ${specifierValueMap} for ${metaKey}`,\n      )\n    }\n    Object.keys(specifierValueMap).forEach((specifier) => {\n      const metaValue = specifierValueMap[specifier]\n      const meta = { [metaKey]: metaValue }\n      specifierMetaMap[specifier] =\n        specifier in specifierMetaMap ? { ...specifierMetaMap[specifier], ...meta } : meta\n    })\n  })\n\n  return specifierMetaMap\n}\n",
    "import { isPlainObject } from \"./isPlainObject.js\"\nimport { assertUrlLike } from \"./assertUrlLike.js\"\n\nexport const assertSpecifierMetaMap = (value, checkComposition = true) => {\n  if (!isPlainObject(value)) {\n    throw new TypeError(`specifierMetaMap must be a plain object, got ${value}`)\n  }\n\n  if (checkComposition) {\n    const plainObject = value\n    Object.keys(plainObject).forEach((key) => {\n      assertUrlLike(key, \"specifierMetaMap key\")\n      const value = plainObject[key]\n      if (value !== null && !isPlainObject(value)) {\n        throw new TypeError(\n          `specifierMetaMap value must be a plain object or null, got ${value} under key ${key}`,\n        )\n      }\n    })\n  }\n}\n",
    "import { assertSpecifierMetaMap } from \"./internal/assertSpecifierMetaMap.js\"\nimport { assertUrlLike } from \"./internal/assertUrlLike.js\"\n\nexport const normalizeSpecifierMetaMap = (specifierMetaMap, url, ...rest) => {\n  assertSpecifierMetaMap(specifierMetaMap, false)\n  assertUrlLike(url, \"url\")\n  if (rest.length) {\n    throw new Error(`received more arguments than expected.\n--- number of arguments received ---\n${2 + rest.length}\n--- number of arguments expected ---\n2`)\n  }\n\n  const specifierMetaMapNormalized = {}\n  Object.keys(specifierMetaMap).forEach((specifier) => {\n    const specifierResolved = String(new URL(specifier, url))\n    specifierMetaMapNormalized[specifierResolved] = specifierMetaMap[specifier]\n  })\n  return specifierMetaMapNormalized\n}\n",
    "import { assertUrlLike } from \"./internal/assertUrlLike.js\"\nimport { assertSpecifierMetaMap } from \"./internal/assertSpecifierMetaMap.js\"\nimport { applySpecifierPatternMatching } from \"./applySpecifierPatternMatching.js\"\n\nexport const urlCanContainsMetaMatching = ({ url, specifierMetaMap, predicate, ...rest }) => {\n  assertUrlLike(url, \"url\")\n  // the function was meants to be used on url ending with '/'\n  if (!url.endsWith(\"/\")) {\n    throw new Error(`url should end with /, got ${url}`)\n  }\n  assertSpecifierMetaMap(specifierMetaMap)\n  if (typeof predicate !== \"function\") {\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n  }\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\nurl, specifierMetaMap, predicate`)\n  }\n\n  // for full match we must create an object to allow pattern to override previous ones\n  let fullMatchMeta = {}\n  let someFullMatch = false\n  // for partial match, any meta satisfying predicate will be valid because\n  // we don't know for sure if pattern will still match for a file inside pathname\n  const partialMatchMetaArray = []\n\n  Object.keys(specifierMetaMap).forEach((specifier) => {\n    const meta = specifierMetaMap[specifier]\n    const { matched, index } = applySpecifierPatternMatching({\n      specifier,\n      url,\n    })\n    if (matched) {\n      someFullMatch = true\n      fullMatchMeta = {\n        ...fullMatchMeta,\n        ...meta,\n      }\n    } else if (someFullMatch === false && index >= url.length) {\n      partialMatchMetaArray.push(meta)\n    }\n  })\n\n  if (someFullMatch) {\n    return Boolean(predicate(fullMatchMeta))\n  }\n\n  return partialMatchMetaArray.some((partialMatchMeta) => predicate(partialMatchMeta))\n}\n",
    "import { assertSpecifierMetaMap } from \"./internal/assertSpecifierMetaMap.js\"\nimport { assertUrlLike } from \"./internal/assertUrlLike.js\"\nimport { applySpecifierPatternMatching } from \"./applySpecifierPatternMatching.js\"\n\nexport const urlToMeta = ({ url, specifierMetaMap, ...rest } = {}) => {\n  assertUrlLike(url)\n  assertSpecifierMetaMap(specifierMetaMap)\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\nurl, specifierMetaMap`)\n  }\n\n  return Object.keys(specifierMetaMap).reduce((previousMeta, specifier) => {\n    const { matched } = applySpecifierPatternMatching({\n      specifier,\n      url,\n    })\n    if (matched) {\n      return {\n        ...previousMeta,\n        ...specifierMetaMap[specifier],\n      }\n    }\n    return previousMeta\n  }, {})\n}\n"
  ],
  "names": [
    "assertUrlLike",
    "value",
    "name",
    "TypeError",
    "isWindowsPathnameSpecifier",
    "hasScheme",
    "specifier",
    "firstChar",
    "test",
    "secondChar",
    "thirdChar",
    "applySpecifierPatternMatching",
    "url",
    "rest",
    "Object",
    "keys",
    "length",
    "Error",
    "applyPatternMatching",
    "pattern",
    "string",
    "patternIndex",
    "index",
    "remainingPattern",
    "remainingString",
    "pass",
    "fail",
    "slice",
    "skipResult",
    "skipUntilMatch",
    "matched",
    "slashIndex",
    "indexOf",
    "skippablePredicate",
    "bestMatch",
    "matchAttempt",
    "skippable",
    "Math",
    "max",
    "isPlainObject",
    "Array",
    "isArray",
    "metaMapToSpecifierMetaMap",
    "metaMap",
    "specifierMetaMap",
    "forEach",
    "metaKey",
    "specifierValueMap",
    "metaValue",
    "meta",
    "assertSpecifierMetaMap",
    "checkComposition",
    "plainObject",
    "key",
    "normalizeSpecifierMetaMap",
    "specifierMetaMapNormalized",
    "specifierResolved",
    "String",
    "URL",
    "urlCanContainsMetaMatching",
    "predicate",
    "endsWith",
    "fullMatchMeta",
    "someFullMatch",
    "partialMatchMetaArray",
    "push",
    "Boolean",
    "some",
    "partialMatchMeta",
    "urlToMeta",
    "reduce",
    "previousMeta"
  ],
  "mappings": "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"
}