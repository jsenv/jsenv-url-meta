{
  "version": 3,
  "file": "main.cjs",
  "sources": [
    "../../src/internal/assertUrlLike.js",
    "../../src/applyPatternMatching.js",
    "../../src/normalizeStructuredMetaMap.js",
    "../../src/internal/isPlainObject.js",
    "../../src/internal/structuredMetaMapToMetaMap.js",
    "../../src/urlCanContainsMetaMatching.js",
    "../../src/urlToMeta.js"
  ],
  "sourcesContent": [
    "export const assertUrlLike = (value, name = \"url\") => {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`${name} must be a url string, got ${value}`)\n  }\n  if (isWindowsPathnameSpecifier(value)) {\n    throw new TypeError(`${name} must be a url but looks like a windows pathname, got ${value}`)\n  }\n  if (!hasScheme(value)) {\n    throw new TypeError(`${name} must be a url and no scheme found, got ${value}`)\n  }\n}\n\nconst isWindowsPathnameSpecifier = (specifier) => {\n  const firstChar = specifier[0]\n  if (!/[a-zA-Z]/.test(firstChar)) return false\n  const secondChar = specifier[1]\n  if (secondChar !== \":\") return false\n  const thirdChar = specifier[2]\n  return thirdChar === \"/\" || thirdChar === \"\\\\\"\n}\n\nconst hasScheme = (specifier) => /^[a-zA-Z]+:/.test(specifier)\n",
    "// https://git-scm.com/docs/gitignore\n// https://github.com/kaelzhang/node-ignore\n\nimport { assertUrlLike } from \"./internal/assertUrlLike.js\"\n\nexport const applyPatternMatching = ({ pattern, url, ...rest } = {}) => {\n  assertUrlLike(pattern, \"pattern\")\n  assertUrlLike(url, \"url\")\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\npattern, url`)\n  }\n  return applyMatching(pattern, url)\n}\n\nconst applyMatching = (pattern, string) => {\n  let patternIndex = 0\n  let index = 0\n  let remainingPattern = pattern\n  let remainingString = string\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // pattern consumed and string consumed\n    if (remainingPattern === \"\" && remainingString === \"\") {\n      // pass because string fully matched pattern\n      return pass({\n        patternIndex,\n        index,\n      })\n    }\n\n    // pattern consumed, string not consumed\n    if (remainingPattern === \"\" && remainingString !== \"\") {\n      // fails because string longer than expected\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // from this point pattern is not consumed\n\n    // string consumed, pattern not consumed\n    if (remainingString === \"\") {\n      // pass because trailing \"**\" is optional\n      if (remainingPattern === \"**\") {\n        return pass({\n          patternIndex: patternIndex + 2,\n          index,\n        })\n      }\n      // fail because string shorted than expected\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // from this point pattern and string are not consumed\n\n    // fast path trailing slash\n    if (remainingPattern === \"/\") {\n      // pass because trailing slash matches remaining\n      if (remainingString[0] === \"/\") {\n        return pass({\n          patternIndex: patternIndex + 1,\n          index: string.length,\n        })\n      }\n\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // fast path trailing '**'\n    if (remainingPattern === \"**\") {\n      // pass because trailing ** matches remaining\n      return pass({\n        patternIndex: patternIndex + 2,\n        index: string.length,\n      })\n    }\n\n    // pattern leading **\n    if (remainingPattern.slice(0, 2) === \"**\") {\n      // consumes \"**\"\n      remainingPattern = remainingPattern.slice(2)\n      patternIndex += 2\n      if (remainingPattern[0] === \"/\") {\n        // consumes \"/\"\n        remainingPattern = remainingPattern.slice(1)\n        patternIndex += 1\n      }\n\n      // pattern ending with ** always match remaining string\n      if (remainingPattern === \"\") {\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      const skipResult = skipUntilMatch({ pattern: remainingPattern, string: remainingString })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] === \"*\") {\n      // consumes \"*\"\n      remainingPattern = remainingPattern.slice(1)\n      patternIndex += 1\n\n      // la c'est plus dÃ©licat, il faut que remainingString\n      // ne soit composÃ© que de truc !== '/'\n      if (remainingPattern === \"\") {\n        const slashIndex = remainingString.indexOf(\"/\")\n        if (slashIndex > -1) {\n          return fail({\n            patternIndex,\n            index: index + slashIndex,\n          })\n        }\n        return pass({\n          patternIndex,\n          index: string.length,\n        })\n      }\n\n      // the next char must not the one expected by remainingPattern[0]\n      // because * is greedy and expect to skip one char\n      if (remainingPattern[0] === remainingString[0]) {\n        return fail({\n          patternIndex: patternIndex - \"*\".length,\n          index,\n        })\n      }\n\n      const skipResult = skipUntilMatch({\n        pattern: remainingPattern,\n        string: remainingString,\n        skippablePredicate: (remainingString) => remainingString[0] !== \"/\",\n      })\n\n      if (!skipResult.matched) {\n        return fail({\n          patternIndex: patternIndex + skipResult.patternIndex,\n          index: index + skipResult.index,\n        })\n      }\n\n      return pass({\n        patternIndex: pattern.length,\n        index: string.length,\n      })\n    }\n\n    if (remainingPattern[0] !== remainingString[0]) {\n      return fail({\n        patternIndex,\n        index,\n      })\n    }\n\n    // consumes next char\n    remainingPattern = remainingPattern.slice(1)\n    remainingString = remainingString.slice(1)\n    patternIndex += 1\n    index += 1\n    continue\n  }\n}\n\nconst skipUntilMatch = ({ pattern, string, skippablePredicate = () => true }) => {\n  let index = 0\n  let remainingString = string\n  let bestMatch = null\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matchAttempt = applyMatching(pattern, remainingString)\n\n    if (matchAttempt.matched) {\n      bestMatch = matchAttempt\n      break\n    }\n\n    const skippable = skippablePredicate(remainingString)\n\n    bestMatch = fail({\n      patternIndex: bestMatch\n        ? Math.max(bestMatch.patternIndex, matchAttempt.patternIndex)\n        : matchAttempt.patternIndex,\n      index: index + matchAttempt.index,\n    })\n\n    if (!skippable) {\n      break\n    }\n\n    // search against the next unattempted string\n    remainingString = remainingString.slice(matchAttempt.index + 1)\n    index += matchAttempt.index + 1\n    if (remainingString === \"\") {\n      bestMatch = {\n        ...bestMatch,\n        index: string.length,\n      }\n      break\n    }\n\n    continue\n  }\n\n  return bestMatch\n}\n\nconst pass = ({ patternIndex, index }) => {\n  return {\n    matched: true,\n    index,\n    patternIndex,\n  }\n}\n\nconst fail = ({ patternIndex, index }) => {\n  return {\n    matched: false,\n    index,\n    patternIndex,\n  }\n}\n",
    "import { assertUrlLike } from \"./internal/assertUrlLike.js\"\n\nexport const normalizeStructuredMetaMap = (structuredMetaMap, url, ...rest) => {\n  assertUrlLike(url, \"url\")\n  if (rest.length) {\n    throw new Error(`received more arguments than expected.\n--- number of arguments received ---\n${2 + rest.length}\n--- number of arguments expected ---\n2`)\n  }\n\n  const structuredMetaMapNormalized = {}\n  Object.keys(structuredMetaMap).forEach((metaProperty) => {\n    const metaValueMap = structuredMetaMap[metaProperty]\n    const metaValueMapNormalized = {}\n    Object.keys(metaValueMap).forEach((pattern) => {\n      const metaValue = metaValueMap[pattern]\n      const specifierResolved = String(new URL(pattern, url))\n      metaValueMapNormalized[specifierResolved] = metaValue\n    })\n    structuredMetaMapNormalized[metaProperty] = metaValueMapNormalized\n  })\n  return structuredMetaMapNormalized\n}\n",
    "export const isPlainObject = (value) => {\n  if (value === null) {\n    return false\n  }\n  if (typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      return false\n    }\n    return true\n  }\n  return false\n}\n",
    "import { isPlainObject } from \"./isPlainObject.js\"\n\nexport const structuredMetaMapToMetaMap = (structuredMetaMap, ...rest) => {\n  if (!isPlainObject(structuredMetaMap)) {\n    throw new TypeError(`structuredMetaMap must be a plain object, got ${structuredMetaMap}`)\n  }\n  if (rest.length) {\n    throw new Error(`received more arguments than expected.\n--- number of arguments received ---\n${1 + rest.length}\n--- number of arguments expected ---\n1`)\n  }\n\n  const metaMap = {}\n  Object.keys(structuredMetaMap).forEach((metaProperty) => {\n    const metaValueMap = structuredMetaMap[metaProperty]\n    if (!isPlainObject(metaValueMap)) {\n      throw new TypeError(\n        `metaValueMap must be plain object, got ${metaValueMap} for ${metaProperty}`,\n      )\n    }\n    Object.keys(metaValueMap).forEach((pattern) => {\n      const metaValue = metaValueMap[pattern]\n      const meta = { [metaProperty]: metaValue }\n      metaMap[pattern] = pattern in metaMap ? { ...metaMap[pattern], ...meta } : meta\n    })\n  })\n  return metaMap\n}\n",
    "import { assertUrlLike } from \"./internal/assertUrlLike.js\"\nimport { structuredMetaMapToMetaMap } from \"./internal/structuredMetaMapToMetaMap.js\"\nimport { applyPatternMatching } from \"./applyPatternMatching.js\"\n\nexport const urlCanContainsMetaMatching = ({ url, structuredMetaMap, predicate, ...rest }) => {\n  assertUrlLike(url, \"url\")\n  // the function was meants to be used on url ending with '/'\n  if (!url.endsWith(\"/\")) {\n    throw new Error(`url should end with /, got ${url}`)\n  }\n  if (typeof predicate !== \"function\") {\n    throw new TypeError(`predicate must be a function, got ${predicate}`)\n  }\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\nurl, structuredMetaMap, predicate`)\n  }\n\n  const metaMap = structuredMetaMapToMetaMap(structuredMetaMap)\n\n  // for full match we must create an object to allow pattern to override previous ones\n  let fullMatchMeta = {}\n  let someFullMatch = false\n  // for partial match, any meta satisfying predicate will be valid because\n  // we don't know for sure if pattern will still match for a file inside pathname\n  const partialMatchMetaArray = []\n\n  Object.keys(metaMap).forEach((pattern) => {\n    const meta = metaMap[pattern]\n    const { matched, index } = applyPatternMatching({\n      pattern,\n      url,\n    })\n    if (matched) {\n      someFullMatch = true\n      fullMatchMeta = {\n        ...fullMatchMeta,\n        ...meta,\n      }\n    } else if (someFullMatch === false && index >= url.length) {\n      partialMatchMetaArray.push(meta)\n    }\n  })\n\n  if (someFullMatch) {\n    return Boolean(predicate(fullMatchMeta))\n  }\n\n  return partialMatchMetaArray.some((partialMatchMeta) => predicate(partialMatchMeta))\n}\n",
    "import { assertUrlLike } from \"./internal/assertUrlLike.js\"\nimport { structuredMetaMapToMetaMap } from \"./internal/structuredMetaMapToMetaMap.js\"\nimport { applyPatternMatching } from \"./applyPatternMatching.js\"\n\nexport const urlToMeta = ({ url, structuredMetaMap, ...rest } = {}) => {\n  assertUrlLike(url)\n  if (Object.keys(rest).length) {\n    throw new Error(`received more parameters than expected.\n--- name of unexpected parameters ---\n${Object.keys(rest)}\n--- name of expected parameters ---\nurl, structuredMetaMap`)\n  }\n\n  const metaMap = structuredMetaMapToMetaMap(structuredMetaMap)\n  return Object.keys(metaMap).reduce((previousMeta, pattern) => {\n    const { matched } = applyPatternMatching({\n      pattern,\n      url,\n    })\n    if (matched) {\n      const meta = metaMap[pattern]\n      return {\n        ...previousMeta,\n        ...meta,\n      }\n    }\n    return previousMeta\n  }, {})\n}\n"
  ],
  "names": [
    "assertUrlLike",
    "value",
    "name",
    "TypeError",
    "isWindowsPathnameSpecifier",
    "hasScheme",
    "specifier",
    "firstChar",
    "test",
    "secondChar",
    "thirdChar",
    "applyPatternMatching",
    "pattern",
    "url",
    "rest",
    "Object",
    "keys",
    "length",
    "Error",
    "applyMatching",
    "string",
    "patternIndex",
    "index",
    "remainingPattern",
    "remainingString",
    "pass",
    "fail",
    "slice",
    "skipResult",
    "skipUntilMatch",
    "matched",
    "slashIndex",
    "indexOf",
    "skippablePredicate",
    "bestMatch",
    "matchAttempt",
    "skippable",
    "Math",
    "max",
    "normalizeStructuredMetaMap",
    "structuredMetaMap",
    "structuredMetaMapNormalized",
    "forEach",
    "metaProperty",
    "metaValueMap",
    "metaValueMapNormalized",
    "metaValue",
    "specifierResolved",
    "String",
    "URL",
    "isPlainObject",
    "Array",
    "isArray",
    "structuredMetaMapToMetaMap",
    "metaMap",
    "meta",
    "urlCanContainsMetaMatching",
    "predicate",
    "endsWith",
    "fullMatchMeta",
    "someFullMatch",
    "partialMatchMetaArray",
    "push",
    "Boolean",
    "some",
    "partialMatchMeta",
    "urlToMeta",
    "reduce",
    "previousMeta"
  ],
  "mappings": "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"
}